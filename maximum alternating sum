recursive and memoised solution
class Solution {
public:
long long memo[1000001][2];
   long long findmax(int idx,bool iseven,vector<int>&nums){
    int n=nums.size();
    if(idx>=n){
        return 0;
    }
    if(memo[idx][iseven]!=-1) return memo[idx][iseven];
    long long nottake=findmax(idx+1,iseven,nums);
    long long val=nums[idx];
    if(!iseven){
        val=-val;
    }
    long long take=findmax(idx+1,!iseven,nums)+val;

    return memo[idx][iseven]=max(take,nottake);
   }
    long long maxAlternatingSum(vector<int>& nums) {
        // vector<int>memo(nums.size(),-1);
        memset(memo,-1,sizeof(memo));
        return findmax(0,true,nums);
    }
};

bottom up approach
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) {
        int n=nums.size();
        vector<vector<long >>t(n+1,vector<long>(2,0));

        for(int i=1;i<n+1;i++){
           //even
           t[i][0]=max(t[i-1][1]-nums[i-1],t[i-1][0]);

           //odd
           t[i][1]=max(t[i-1][0]+nums[i-1],t[i-1][1]);
        }
        return max(t[n][0],t[n][1]);
    }
};
