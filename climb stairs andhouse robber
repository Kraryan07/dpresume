recursion
int climbStairs(int n) {
        if(n<0) return 0;
        if(n==0) return 1;

        return climbStairs(n-1)+climbStairs(n-2);
    }

memoization
int findval(int n,vector<int>&memo){
      if(n<0) return 0;
      if(n==0) return 1;

      if(memo[n]!=-1) return memo[n];

      return memo[n]=findval(n-1,memo)+findval(n-2,memo);
    }
    int climbStairs(int n) {
        if(n<0) return 0;
        if(n==0) return 1;
        vector<int>memo(n+1,-1);
        return findval(n,memo);
    }

botttom up approch
 int climbStairs(int n) {
         if(n<=2) return n;

         vector<int>arr(n+1,0);

         arr[0]=0;
         arr[1]=1;
         arr[2]=2;

         for(int i=3;i<=n;i++){
            arr[i]=arr[i-1]+arr[i-2];     
            }
            return arr[n];
         }

space optimization we need only past 2 values
int climbStairs(int n) {
         if(n<=2) return n;

        //  vector<int>arr(n+1,0);

         int a=0;
         int b=1;
         int c=2;
        int x=0;
         for(int i=3;i<=n;i++){
            x=b+c;
            b=c;
            c=a;     
            }
            return x;
         }


house robber 
recursionm and memoization
int maxcount(int i,vector<int>&nums,int n,vector<int>&memo){
    if(i>=n) return 0;
     if(memo[i]!=-1) return memo[i];
    int steal=nums[i]+maxcount(i+2,nums,n,memo);
    int notsteal=maxcount(i+1,nums,n,memo);
    
    return memo[i]=max(steal,notsteal);
}
    int rob(vector<int>& nums) {
         int n=nums.size();
         vector<int>memo(n,-1);
         return maxcount(0,nums,n,memo);
    }
